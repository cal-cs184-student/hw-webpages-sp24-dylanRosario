<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c4{background-color:#ffffff;padding-top:12pt;padding-bottom:12pt;line-height:2.0;orphans:2;widows:2;text-align:left;height:11pt}.c13{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c6{padding-top:0pt;padding-bottom:0pt;line-height:2.0;orphans:2;widows:2;text-align:left;height:11pt}.c12{background-color:#ffffff;padding-top:18pt;padding-bottom:4pt;line-height:2.0;orphans:2;widows:2;text-align:center}.c9{background-color:#ffffff;padding-top:14pt;padding-bottom:4pt;line-height:2.0;orphans:2;widows:2;text-align:center}.c3{background-color:#ffffff;padding-top:12pt;padding-bottom:12pt;line-height:2.0;orphans:2;widows:2;text-align:center}.c2{padding-top:0pt;text-indent:36pt;padding-bottom:0pt;line-height:2.0;orphans:2;widows:2;text-align:left}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c14{color:#121212;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Arial";font-style:normal}.c5{background-color:#ffffff;padding-top:12pt;padding-bottom:12pt;line-height:2.0;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:0pt;line-height:2.0;orphans:2;widows:2;text-align:left}.c1{padding-top:0pt;padding-bottom:0pt;line-height:2.0;orphans:2;widows:2;text-align:center}.c8{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c16{font-size:12pt;font-family:"Times New Roman";font-weight:700}.c10{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c17{color:#000000}.c15{font-style:italic}.c11{text-indent:36pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c10 doc-content"><p class="c1"><span class="c13">CS 184/284A: Computer Graphics and Imaging, Spring 2024</span></p><p class="c1"><span class="c13">Project 2: Mesh Edit</span></p><p class="c1"><span class="c16">Dylan Rosario</span></p><p class="c1"><span class="c0">Overview</span></p><p class="c7"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This assignment aims to implement a multitude of geometric modeling techniques. First, the de Casteljau Subdivision method of creating multiple control points allowed for the drawing of bezier curves and surfaces. Then, a number of methods involving triangle meshes and the half-edge data structure are created. This includes splitting and flipping edges of the existing triangles in an effort to produce a clearer image. Particularly, I found the way that shading of an object could change based on the triangle meshing implementation to be interesting. This provides a tangible example of the powers of the half-edge data structure to produce a visual image. </span></p><p class="c1"><span class="c0">Section I: Bezier Curves and Surfaces</span></p><p class="c1"><span class="c0">Part 1: Bezier Curves with 1D de Casteljau Subdivision</span></p><p class="c7"><span class="c0">Briefly explain de Casteljau&#39;s algorithm and how you implemented it in order to evaluate Bezier curves.</span></p><p class="c2"><span class="c8">This method takes an input of a set of control points and works by using subdivisions and recursively calling itself until there is only a single control point left. There is a constant </span><span class="c8 c15">t</span><span class="c0">&nbsp;which is on a scale of 0 to 1 and it represents the distance along each line segment connecting the control points where the next control point on the next level will be. Each level is recursively inputted until that final point is left and a bezier curve can be created.</span></p><p class="c6 c11"><span class="c0"></span></p><p class="c7"><span class="c0">Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 433.53px; height: 288.09px;"><img alt="" src="images/image13.png" style="width: 433.53px; height: 288.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c0">Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press E to step through. Toggle C to show the completed Bezier curve as well.</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.02px; height: 204.34px;"><img alt="" src="images/image1.png" style="width: 307.02px; height: 204.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.50px; height: 204.34px;"><img alt="" src="images/image15.png" style="width: 305.50px; height: 204.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.50px; height: 204.00px;"><img alt="" src="images/image3.png" style="width: 307.50px; height: 204.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 304.50px; height: 204.00px;"><img alt="" src="images/image12.png" style="width: 304.50px; height: 204.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.55px; height: 203.36px;"><img alt="" src="images/image8.png" style="width: 303.55px; height: 203.36px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 309.50px; height: 203.67px;"><img alt="" src="images/image11.png" style="width: 309.50px; height: 203.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c0"></span></p><p class="c7"><span class="c8">Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter </span><span class="c8 c15">t</span><span class="c0">&nbsp;via mouse scrolling.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 411.00px; height: 272.52px;"><img alt="" src="images/image4.png" style="width: 411.00px; height: 272.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c9" id="h.cbsv5kbdlyw3"><span class="c0">Part 2: Bezier Surfaces with Separable 1D de Casteljau</span></h3><p class="c5"><span class="c0">Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.</span></p><p class="c5"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementing this algorithm for Bezier surfaces is quite similar to the process used for the Bezier curves done previously, however there are 2D matrices that are now considered. Each row of this 2D input is considered its own bezier curve and the final control point can be calculated for each row just as before. Once each row is iterated through, those final control points of each row formulate their own curve and de Casteljau&rsquo;s algorithm is then performed on this data set. This all results in a bezier surface.</span></p><p class="c5"><span class="c0">Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 538.00px; height: 356.20px;"><img alt="" src="images/image5.png" style="width: 538.00px; height: 356.20px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c12" id="h.bpoun51nhyn7"><span class="c0">Section II: Triangle Meshes and Half-Edge Data Structure</span></h2><h3 class="c9" id="h.swppm8l2yode"><span class="c0">Part 3: Area-Weighted Vertex Normals</span></h3><p class="c5"><span class="c0">Briefly explain how you implemented the area-weighted vertex normals.</span></p><p class="c5"><span class="c8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To find the area-weighted vertex normals, the triangle faces of every face incident to the specified vertex needs to be considered. Then by taking the cross product of the edges of these triangles, and then normalizing this amount after summing each face, the area-weighted normal of a vertex is calculated.</span></p><p class="c5"><span class="c0">Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use Q to toggle default flat shading and Phong shading</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 365.53px; height: 244.50px;"><img alt="" src="images/image14.png" style="width: 365.53px; height: 244.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 364.50px; height: 241.32px;"><img alt="" src="images/image2.png" style="width: 364.50px; height: 241.32px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c9" id="h.btlncds1guyg"><span class="c0">Part 4: Edge Flip</span></h3><p class="c5"><span class="c0">Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c5"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I implemented this operation by first defining every edge, half-edge, vertex, and face in the two triangle configuration. This provides a basis for the rest of the flipping operation. Since no new elements are created when flipping an edge from a set of two vertice to the other two, the only steps left are to reassign every pointer that was just created. For debugging, I found it most helpful to draw out the initial and final triangle configurations on paper. By visualizing exactly what pointers I wanted to change, it made debugging much easier.</span></p><p class="c5"><span class="c0">Show screenshots of the teapot before and after some edge flips.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.38px; height: 290.50px;"><img alt="" src="images/image10.png" style="width: 434.38px; height: 290.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.52px; height: 289.36px;"><img alt="" src="images/image9.png" style="width: 434.52px; height: 289.36px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c0">Write about your eventful debugging journey, if you have experienced one.</span></p><p class="c5"><span class="c8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The most difficult part about debugging was the sheer amount of pointers and mesh elements there were to keep track of. I often found myself overwhelmed by this and confused the inside vs. outside half edges when reassigning. This led to problems in the algorithm as only the inside half-edges were allowed &nbsp;to have redefined faces and next pointers. Eventually, drawing out labeled diagrams alleviated this confusion.</span></p><h3 class="c9" id="h.agtdijtzfco8"><span class="c8 c17">Part 5: Edge Split</span></h3><p class="c5"><span class="c0">Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c5"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To begin the edge split operation, I started similarly to edge flip by first defining every mesh element of the original mesh being considered. Then after ensuring that the edge being split was not considered a boundary edge, I created every new element that would be needed to split an edge: one vertex, two faces, 6 half-edges, and 3 edges. Then, it simply became a tedious task of reassigning every pointer according to the diagram I drew on paper.</span></p><p class="c4"><span class="c0"></span></p><p class="c5"><span class="c0">Show screenshots of a mesh before and after some edge splits.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.38px; height: 290.50px;"><img alt="" src="images/image10.png" style="width: 434.38px; height: 290.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 442.00px; height: 293.39px;"><img alt="" src="images/image7.png" style="width: 442.00px; height: 293.39px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c0">Show screenshots of a mesh before and after a combination of both edge splits and edge flips.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.38px; height: 290.50px;"><img alt="" src="images/image10.png" style="width: 434.38px; height: 290.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 479.50px; height: 319.99px;"><img alt="" src="images/image6.png" style="width: 479.50px; height: 319.99px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c0">Write about your eventful debugging journey, if you have experienced one.</span></p><p class="c5"><span class="c8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This debugging process went relatively smoothly. The only issues I had came when I was defining the new elements to be added, and I would error when attempting to split an edge. To remedy this, I re-read the mesh structure code to find the exact syntax of defining new edges, faces, half-edges, and vertices. Once editing my code to fit this syntax, the operation ran as intended.</span></p><p class="c4"><span class="c0"></span></p><p class="c4"><span class="c0"></span></p><p class="c6"><span class="c0"></span></p><p class="c6"><span class="c0"></span></p></body></html>