<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_u1e16bq4tfk-7{list-style-type:none}ul.lst-kix_u1e16bq4tfk-8{list-style-type:none}.lst-kix_u1e16bq4tfk-3>li:before{content:"\0025cf   "}.lst-kix_u1e16bq4tfk-2>li:before{content:"\0025a0   "}.lst-kix_u1e16bq4tfk-4>li:before{content:"\0025cb   "}.lst-kix_u1e16bq4tfk-1>li:before{content:"\0025cb   "}.lst-kix_u1e16bq4tfk-5>li:before{content:"\0025a0   "}ul.lst-kix_u1e16bq4tfk-5{list-style-type:none}ul.lst-kix_u1e16bq4tfk-6{list-style-type:none}ul.lst-kix_u1e16bq4tfk-3{list-style-type:none}.lst-kix_u1e16bq4tfk-0>li:before{content:"\0025cf   "}ul.lst-kix_u1e16bq4tfk-4{list-style-type:none}.lst-kix_u1e16bq4tfk-6>li:before{content:"\0025cf   "}.lst-kix_u1e16bq4tfk-8>li:before{content:"\0025a0   "}ul.lst-kix_u1e16bq4tfk-1{list-style-type:none}ul.lst-kix_u1e16bq4tfk-2{list-style-type:none}ul.lst-kix_u1e16bq4tfk-0{list-style-type:none}.lst-kix_u1e16bq4tfk-7>li:before{content:"\0025cb   "}ol{margin:0;padding:0}table td,table th{padding:0}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c4{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c0{padding-top:14pt;padding-bottom:0pt;line-height:2.0;orphans:2;widows:2;text-align:left}.c2{padding-top:14pt;padding-bottom:0pt;line-height:2.0;orphans:2;widows:2;text-align:center}.c3{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c5{font-size:12pt;font-family:"Times New Roman";font-weight:700}.c6{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c3 doc-content"><p class="c2"><span class="c4">CS 184/284A: Computer Graphics and Imaging, Spring 2024</span></p><p class="c2"><span class="c4">Homework 4: Cloth Sim</span></p><p class="c2"><span class="c5">Dylan Rosario</span></p><p class="c2"><span class="c1">Overview</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For the project, the goal is to create an accurate simulation of a cloth. The cloth which is based upon a system of point masses and springs, will have various physical constraints placed upon them to mimic a realistic behavior. The first step is to create a grid that defines each of the point masses and springs, this setup allows for all of the future parts to build upon it. After this, I implemented the ability for the cloth to handle collisions with both other objects but also itself. Lastly, a shader is created in order to provide interesting colors and textures to the cloth.</span></p><p class="c2"><span class="c1">Part 1: Masses and Springs</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For the first part, the cloth itself is imagined as a 2D grid with point masses evenly spaced throughout. The goal is to store every point mass within a vector in row-major order, making access simple. With a double for loop that parses through the coordinate system of the cloth, each point mass is checked against the predefined set of pinned masses to determine whether to set the pin boolean to true or false. Then, the point mass can be stored in the aforementioned vector.</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The process for springs is relatively similar. I looped through every point mass and assigned structural, shearing, or bending spring properties to every eligible spring. The distinction between these springs is based upon the distance relationship between any 2 point masses. Then, these springs can be stored within their own vector in order to access in later parts.</span></p><p class="c0"><span class="c1">Unique Viewing Angle:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 310.95px;"><img alt="" src="images/image5.png" style="width: 384.00px; height: 310.95px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Without any shearing constraints:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 314.69px;"><img alt="" src="images/image10.png" style="width: 384.00px; height: 314.69px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">With only shearing constraints:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 311.88px;"><img alt="" src="images/image3.png" style="width: 384.00px; height: 311.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">With all constraints:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 311.88px;"><img alt="" src="images/image9.png" style="width: 384.00px; height: 311.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1">Part 2: Simulation via Numerical Integration</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each mass undergoes forces which include at this point gravity and other springs. The goal is to sum all of these forces together and assign them to each point mass, and then calculating the new position of the point masses. With gravity, this is the same at all times for each point mass. The spring forces now need to be added to gravity which can be done since force is a vector. Hooke&rsquo;s law provides the framework for the force felt by a spring, which applies to both point masses in equal magnitude but opposite direction. By looping through every spring and basing calculations on the type of spring present, the total forces can be found.</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The final step included altering the constraints, so that the spring length is never 10% greater than its resting length at any given point in time. This implementation follows what is outlined in the SIGGRAPH 1995 Provot paper. By changing the position of one end of the spring, the other end, or both ends depended on the pin status of the point mass each spring is linked to. It is important to remember that each end of a spring corresponds to a point mass.</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As seen in the comparison of ks values, a lower ks has more ripples and a lot more movement. The high ks value leads to a relatively flat and stable sheet with less dip at the top. The effect of density appears to be the inverse of the effect ks had. Higher density led to more ripples in the cloth, and the low density is flat with relatively little dip at the top. When changing damping, the dip at the top stayed about the same. However, higher damping led to less ripples in the cloth and an overall more stable cloth that is less prone to movement.</span></p><p class="c0"><span class="c1">Low ks vs High ks:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 248.60px;"><img alt="" src="images/image15.png" style="width: 307.20px; height: 248.60px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 247.65px;"><img alt="" src="images/image8.png" style="width: 307.20px; height: 247.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Low Density vs High Density:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 247.81px;"><img alt="" src="images/image16.png" style="width: 307.20px; height: 247.81px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 247.81px;"><img alt="" src="images/image17.png" style="width: 307.20px; height: 247.81px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Low Damping vs High Damping:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 248.83px;"><img alt="" src="images/image13.png" style="width: 307.20px; height: 248.83px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 248.83px;"><img alt="" src="images/image14.png" style="width: 307.20px; height: 248.83px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Final Resting of scene/pinned4.json with Original Parameters:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 249.86px;"><img alt="" src="images/image12.png" style="width: 307.20px; height: 249.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.20px; height: 249.86px;"><img alt="" src="images/image1.png" style="width: 307.20px; height: 249.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c6"><span class="c1"></span></p><p class="c2"><span class="c1">Part 3: Handling Collisions with Other Objects</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determining collisions with spheres and planes is a relatively process. For sphere collisions, they occur when the distance between the point mass and the center of the sphere is less than or equal to the radius of the sphere. To correct the collision, the position of the point mass is updated relative to how deep inside the sphere it is, so it now is placed outside. For planes, it is quite similar. Collisions are when the last_position and position pointers for the point mass are on opposite sides of the plane. Once again, a correction to the position of the point mass is made relative to how far past the plane it traveled.</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After implementing both methods for what to do when a collision occurs with a sphere or plane, I created another set of for loops in the general simulation to check for these collisions. By looping through every collision object for every point mass in the cloth, I used the collide() function to call upon my sphere and plane methods when a collision takes place.</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As seen from the images for the sphere, it is apparent that as ks increases, the stiffness of the cloth increases. There are less folds in the cloth and it does not hang down as low with a higher ks.</span></p><p class="c0"><span class="c1">Sphere (ks = 5000):</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 309.56px;"><img alt="" src="images/image7.png" style="width: 384.00px; height: 309.56px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Sphere (ks = 500):</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 311.93px;"><img alt="" src="images/image11.png" style="width: 384.00px; height: 311.93px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Sphere (ks = 50000):</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 309.56px;"><img alt="" src="images/image6.png" style="width: 384.00px; height: 309.56px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Plane:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 311.04px;"><img alt="" src="images/image4.png" style="width: 384.00px; height: 311.04px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1">Part 4: Handling Self-Collisions</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The goal of this section is to implement self-collisions, so certain behavior can occur, like a cloth folding over itself when being dropped straight down vertically. The first step is to implement a hashmap in order to speed up runtime and increase efficiency. Each point mass is given a unique hash code based on its position, and this then populates the hashmap. This hashmap will be used to look up potential collision candidates quickly within the self-collision function. In this function, I will check for possible collisions that are defined as when a candidate point mass is within 2 * thickness of the point mass in question. Then, a correction vector is applied to the position to create this amount of separation. To tie it all together, every point mass is looped through and checked with the self collision function.</span></p><p class="c0"><span class="c1">Cloth Folding on Itself (unfortunately did not fold):</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 403.20px; height: 326.31px;"><img alt="" src="images/image2.png" style="width: 403.20px; height: 326.31px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1">Part 5: Shaders</span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unfortunately, my local compiler had issues with the shader files, so I will explain here how I would have implemented each task for this final part. For diffuse shading, I would program in the following equation:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 464.00px; height: 62.00px;"><img alt="" src="images/image18.png" style="width: 464.00px; height: 62.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This defines the diffusing lighting present, and by passing this value in to the proper function, the diffuse color can be altered.</span></p></body></html>